package sorting.simpleSorting;

import sorting.AbstractSorting;
import static util.Util.swap;

/**
 * As the insertion sort algorithm iterates over the array, it makes the
 * assumption that the visited positions are already sorted in ascending order,
 * which means it only needs to find the right position for the current element
 * and insert it there.
 */
public class InsertionSort<T extends Comparable<T>> extends AbstractSorting<T> {

	/*
	 * Recebe array delimitado por um indice a esquerda(leftIndex) 
	 * e por um a direita(rightIndex), assumindo apenas esta porcao como a que sera
	 * ordenada. Aqui uma implementacao simples de selectionsort na qual varre o array
	 * a cada vez procurando o menor elemento, excluindo o menor elemento anterior visto
	 * que cada iteracao de busca de novo menor elemento parte da posicao adjacente(a direita)
	 * ao menor elemento anterior. A cada novo menor elemento o posiciona no indice atual do
	 * contador i do for, na qual sera desconsiderado nas proximas iteracoes, ate que o ultimo menor
	 * elemento(o maior no caso) esteja posicionado no ultimo indice.
	 */
	/**
	 * Ordena uma porcao definida de um array, podendo compreender todo o array
	 * caso seja passado como argumentos 0 e array.length-1 como segundo e terceiro
	 * argumentos respectivamente.
	 * 
	 * @param array			array de tipo generico no qual as operacoes de ordenacao serao realizadas
	 * @param leftIndex		indice na qual delimita o comeco da porcao a ser ordenada
	 * @param rightIndex	indice na qual delimita o final da porcao a ser ordenada
	 * 
	 * @author 				Gabriel Fernandes
	 */
	@Override
	public void sort(T[] array, int leftIndex, int rightIndex) {
		for (int i = leftIndex; i < rightIndex; i++) {
			if (array[i].compareTo(array[i+1]) > 0) {
				int insertionPointer = i;
				do {
					swap(array, insertionPointer, insertionPointer+1);
					insertionPointer--;
					if (insertionPointer < 0) {
						break;
					}
				}
				while (array[insertionPointer].compareTo(array[insertionPointer+1]) > 0
										&& insertionPointer >= leftIndex);
			}
		}
	}
}